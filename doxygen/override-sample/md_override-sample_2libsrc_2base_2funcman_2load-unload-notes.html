<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Document of c-modernization-kit (override-sample): 動的ライブラリのロード・アンロードに関する実装メモ</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Document of c-modernization-kit (override-sample)<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">動的ライブラリのロード・アンロードに関する実装メモ </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>dlopen / LoadLibrary の都度オープン・クローズについて</h1>
<p><span class="tt"><a class="el" href="funcman__get__func_8c.html" title="拡張可能な関数の動的ロードを行い、関数アドレスを返却します。">funcman_get_func.c</a></span> の <span class="tt"><a class="el" href="libbase_8h.html#a3d206cca6cf4241fbbf1b10be7c8714c" title="拡張関数ポインタを返します。この関数は内部用です。">_funcman_get_func()</a></span> では、初回呼び出し時のみ以下を実行します。</p>
<div class="fragment"><div class="line">dlopen(&quot;lib_name.so&quot;, RTLD_LAZY)   // ① ライブラリのロード / 参照カウント増加</div>
<div class="line">dlsym(handle, &quot;func_name&quot;)         // ② シンボルテーブル検索</div>
</div><!-- fragment --><p><span class="tt">lib_name</span> と <span class="tt">func_name</span> は <span class="tt"><a class="el" href="libbase_8h.html#a1c2f542ca1259a145d01ca540d8181cb" title="funcman_object ポインタ配列を初期化します。">funcman_init()</a></span> が設定ファイルから読み込んだ値です。</p>
<p>2 回目以降は <span class="tt"><a class="el" href="structfuncman__object.html" title="関数ポインタキャッシュエントリ。">funcman_object</a></span> の <span class="tt">handle</span> と <span class="tt">func_ptr</span> にキャッシュされた値をそのまま使用します。</p>
<div class="fragment"><div class="line">func_ptr(...)                    // ③ 本来の処理 (キャッシュ済みポインタを呼び出し)</div>
</div><!-- fragment --><h2>各操作のコスト</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">操作  </th><th class="markdownTableHeadNone">初回 (コールド)  </th><th class="markdownTableHeadNone">2 回目以降 (ウォーム)  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">dlopen</span>  </td><td class="markdownTableBodyNone">大 (ファイル検索・mmap・シンボル解決・コンストラクタ実行)  </td><td class="markdownTableBodyNone">中 (前回の <span class="tt">dlclose</span> でアンロード済みなら再ロードに近いコスト)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">dlsym</span>  </td><td class="markdownTableBodyNone">中 (ハッシュテーブル検索、数 μs 程度)  </td><td class="markdownTableBodyNone">同左  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">dlclose</span>  </td><td class="markdownTableBodyNone">中 (参照カウント -1、0 になればデストラクタ + アンマップ)  </td><td class="markdownTableBodyNone">同左  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">関数呼び出し本体  </td><td class="markdownTableBodyNone">ns 単位  </td><td class="markdownTableBodyNone">ns 単位  </td></tr>
</table>
<p>Linux / Windows ともに <span class="tt">dlopen</span> / <span class="tt">LoadLibrary</span> は内部で参照カウントを管理しています。<span class="tt">dlclose</span> で参照カウントが 0 になると OS はライブラリをアンマップするため、次回の <span class="tt">dlopen</span> は冷たいロードに近いコストが再びかかります。キャッシュパターンではこのコストを初回のみに抑えます。</p>
<h2>呼び出し頻度別の判断</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">呼び出し頻度  </th><th class="markdownTableHeadNone">判断  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">起動時や設定変更時など低頻度  </td><td class="markdownTableBodyNone">無視できます  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Web API のリクエスト単位など中頻度  </td><td class="markdownTableBodyNone">測定して判断してください  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ループ内・高速処理パスなど高頻度  </td><td class="markdownTableBodyNone">無視できません。<span class="tt">dlopen</span> の数 μs ~ 数十 μs が積み重なり支配的になります  </td></tr>
</table>
<h1>ハンドルと関数ポインタのキャッシュ</h1>
<p><span class="tt"><a class="el" href="funcman__get__func_8c.html" title="拡張可能な関数の動的ロードを行い、関数アドレスを返却します。">funcman_get_func.c</a></span> では、<span class="tt"><a class="el" href="structfuncman__object.html" title="関数ポインタキャッシュエントリ。">funcman_object</a></span> 構造体の <span class="tt">handle</span> と <span class="tt">func_ptr</span> メンバにハンドルと関数ポインタを保持します。<span class="tt"><a class="el" href="dllmain__libbase_8c.html" title="base.so / base.dll のロード・アンロード時処理。">dllmain_libbase.c</a></span> からも参照するため、<span class="tt"><a class="el" href="funcman__libbase_8c.html" title="funcman が管理する関数ポインタの実定義。">funcman_libbase.c</a></span> で実体を定義し、<span class="tt"><a class="el" href="funcman__libbase_8h.html" title="funcman が管理する関数ポインタの extern 定義。">funcman_libbase.h</a></span> の <span class="tt">extern</span> 宣言で共有します。</p>
<div class="fragment"><div class="line"><span class="comment">/* funcman_libbase.c での実体定義 */</span></div>
<div class="line"><span class="keyword">static</span> <a class="code hl_struct" href="structfuncman__object.html">funcman_object</a> <a class="code hl_variable" href="funcman__libbase_8c.html#aa0005d8e605122c4c741f588c7c731ad">sfo_sample_func</a> = <a class="code hl_define" href="libbase_8h.html#a8c9c49693e5583c4c4a25f5183ed9d1f">NEW_FUNCMAN_OBJECT</a>(<span class="stringliteral">&quot;sample_func&quot;</span>, <a class="code hl_typedef" href="funcman__libbase_8h.html#a85e0d0d015e4bf0dea97a412623e5245">sample_func_t</a>);</div>
<div class="line"><a class="code hl_struct" href="structfuncman__object.html">funcman_object</a> *<span class="keyword">const</span> <a class="code hl_variable" href="funcman__libbase_8c.html#aeba95cf5e36a8617c791a5165a49e023">pfo_sample_func</a> = &amp;<a class="code hl_variable" href="funcman__libbase_8c.html#aa0005d8e605122c4c741f588c7c731ad">sfo_sample_func</a>;</div>
<div class="ttc" id="afuncman__libbase_8c_html_aa0005d8e605122c4c741f588c7c731ad"><div class="ttname"><a href="funcman__libbase_8c.html#aa0005d8e605122c4c741f588c7c731ad">sfo_sample_func</a></div><div class="ttdeci">static funcman_object sfo_sample_func</div><div class="ttdoc">sample_func 用の funcman オブジェクト実体。</div><div class="ttdef"><b>Definition</b> <a href="funcman__libbase_8c_source.html#l00027">funcman_libbase.c:27</a></div></div>
<div class="ttc" id="afuncman__libbase_8c_html_aeba95cf5e36a8617c791a5165a49e023"><div class="ttname"><a href="funcman__libbase_8c.html#aeba95cf5e36a8617c791a5165a49e023">pfo_sample_func</a></div><div class="ttdeci">funcman_object *const pfo_sample_func</div><div class="ttdoc">sample_func に対応する funcman オブジェクトへのポインタ。</div><div class="ttdef"><b>Definition</b> <a href="funcman__libbase_8c_source.html#l00029">funcman_libbase.c:29</a></div></div>
<div class="ttc" id="afuncman__libbase_8h_html_a85e0d0d015e4bf0dea97a412623e5245"><div class="ttname"><a href="funcman__libbase_8h.html#a85e0d0d015e4bf0dea97a412623e5245">sample_func_t</a></div><div class="ttdeci">int(* sample_func_t)(const int, const int, int *)</div><div class="ttdoc">sample_func に対応する関数ポインタの型定義。</div><div class="ttdef"><b>Definition</b> <a href="funcman__libbase_8h_source.html#l00026">funcman_libbase.h:26</a></div></div>
<div class="ttc" id="alibbase_8h_html_a8c9c49693e5583c4c4a25f5183ed9d1f"><div class="ttname"><a href="libbase_8h.html#a8c9c49693e5583c4c4a25f5183ed9d1f">NEW_FUNCMAN_OBJECT</a></div><div class="ttdeci">#define NEW_FUNCMAN_OBJECT(key, type)</div><div class="ttdoc">funcman_object 静的変数の初期化マクロ。</div><div class="ttdef"><b>Definition</b> <a href="libbase_8h_source.html#l00188">libbase.h:188</a></div></div>
<div class="ttc" id="astructfuncman__object_html"><div class="ttname"><a href="structfuncman__object.html">funcman_object</a></div><div class="ttdoc">関数ポインタキャッシュエントリ。</div><div class="ttdef"><b>Definition</b> <a href="libbase_8h_source.html#l00164">libbase.h:165</a></div></div>
</div><!-- fragment --><p><span class="tt"><a class="el" href="structfuncman__object.html" title="関数ポインタキャッシュエントリ。">funcman_object</a></span> には以下のキャッシュフィールドが含まれます。</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *func_key;             <span class="comment">/* この関数インスタンスの識別キー */</span></div>
<div class="line">    <span class="keywordtype">char</span> lib_name[<a class="code hl_define" href="libbase_8h.html#a58b3887b6f955524e2d3c44394dd1bc3">FUNCMAN_NAME_MAX</a>];  <span class="comment">/* 拡張子なしライブラリ名 */</span></div>
<div class="line">    <span class="keywordtype">char</span> func_name[<a class="code hl_define" href="libbase_8h.html#a58b3887b6f955524e2d3c44394dd1bc3">FUNCMAN_NAME_MAX</a>]; <span class="comment">/* 関数シンボル名 */</span></div>
<div class="line">    <a class="code hl_define" href="libbase_8h.html#a2cb1993b274d4b60febe53b80d0ef454">MODULE_HANDLE</a> handle;             <span class="comment">/* キャッシュ済みハンドル (NULL = 未ロード) */</span></div>
<div class="line">    <span class="keywordtype">void</span> *func_ptr;                   <span class="comment">/* キャッシュ済み関数ポインタ (NULL = 未取得) */</span></div>
<div class="line">    <span class="keywordtype">int</span> resolved;                     <span class="comment">/* 解決済フラグ (0 = 未解決) */</span></div>
<div class="line">    <span class="comment">/* ... mutex (Linux) または lock (Windows) ... */</span></div>
<div class="line">} <a class="code hl_struct" href="structfuncman__object.html">funcman_object</a>;</div>
<div class="ttc" id="alibbase_8h_html_a2cb1993b274d4b60febe53b80d0ef454"><div class="ttname"><a href="libbase_8h.html#a2cb1993b274d4b60febe53b80d0ef454">MODULE_HANDLE</a></div><div class="ttdeci">#define MODULE_HANDLE</div><div class="ttdoc">Linux/Windows 共通のモジュールハンドル型。</div><div class="ttdef"><b>Definition</b> <a href="libbase_8h_source.html#l00149">libbase.h:149</a></div></div>
<div class="ttc" id="alibbase_8h_html_a58b3887b6f955524e2d3c44394dd1bc3"><div class="ttname"><a href="libbase_8h.html#a58b3887b6f955524e2d3c44394dd1bc3">FUNCMAN_NAME_MAX</a></div><div class="ttdeci">#define FUNCMAN_NAME_MAX</div><div class="ttdoc">lib_name / func_name 配列の最大長 (終端 &#39;\0&#39; を含む)。</div><div class="ttdef"><b>Definition</b> <a href="libbase_8h_source.html#l00154">libbase.h:154</a></div></div>
</div><!-- fragment --><h2>スレッドセーフな実装</h2>
<h3>なぜ必要か</h3>
<p><span class="tt">resolved == 0</span> の単純なチェックでは、複数のスレッドが同時に関数ポインタを取得しようとしたとき競合が発生します。</p>
<div class="plantumlgraph">
<object type="image/svg+xml" data="inline_umlgraph_1.svg"></object>
<div class="caption">
競合シナリオ (排他制御なし)</div>
</div>
<p>この競合が引き起こす問題は複数あります。</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">問題  </th><th class="markdownTableHeadNone">内容  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">二重ロード  </td><td class="markdownTableBodyNone"><span class="tt">dlopen</span> が 2 回実行され、参照カウントが期待より増加する。<span class="tt"><a class="el" href="dllmain_8h.html#a817942d94fb255bd3eab726419c96e59" title="ライブラリのアンロード時に呼び出されるフック関数。">onUnload()</a></span> での <span class="tt">dlclose</span> が 1 回では不十分になる  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">部分書き込みの参照  </td><td class="markdownTableBodyNone">スレッド A が <span class="tt">handle</span> を書き込んでいる途中でスレッド B が読むと、不完全な値を参照する可能性がある (メモリバリアなしでは CPU の書き込み順序が保証されない)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">func_ptr</span> の不整合  </td><td class="markdownTableBodyNone"><span class="tt">handle</span> の書き込みと <span class="tt">func_ptr</span> の書き込みの間に別スレッドが割り込むと、<span class="tt">handle != NULL</span> なのに <span class="tt">func_ptr == NULL</span> という矛盾した状態が見える  </td></tr>
</table>
<h3>実装方法</h3>
<p><span class="tt"><a class="el" href="libbase_8h.html#a3d206cca6cf4241fbbf1b10be7c8714c" title="拡張関数ポインタを返します。この関数は内部用です。">_funcman_get_func()</a></span> では <span class="tt">pthread_mutex_t</span> (Linux) または <span class="tt">SRWLOCK</span> (Windows) と double-checked locking パターンを組み合わせています。</p>
<div class="fragment"><div class="line"><span class="comment">/* 早期リターン: ロード完了後はロックなしで高速にキャッシュを参照する */</span></div>
<div class="line"><span class="keywordflow">if</span> (fobj-&gt;resolved != 0)</div>
<div class="line">    <span class="keywordflow">return</span> fobj-&gt;func_ptr;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* ロック取得 */</span></div>
<div class="line"><span class="preprocessor">#ifndef _WIN32</span></div>
<div class="line">pthread_mutex_lock(&amp;fobj-&gt;mutex);</div>
<div class="line"><span class="preprocessor">#else  </span><span class="comment">/* _WIN32 */</span><span class="preprocessor"></span></div>
<div class="line">AcquireSRWLockExclusive(&amp;fobj-&gt;lock);</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* _WIN32 */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* ロック取得後に再確認 (double-checked locking):</span></div>
<div class="line"><span class="comment"> * 他スレッドが先にロードを完了していた場合はスキップする */</span></div>
<div class="line"><span class="keywordflow">if</span> (fobj-&gt;resolved == 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* ... dlopen / LoadLibrary ... */</span></div>
<div class="line">    <span class="comment">/* ... dlsym / GetProcAddress ... */</span></div>
<div class="line">    fobj-&gt;resolved = 1;  <span class="comment">/* 解決済 */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef _WIN32</span></div>
<div class="line">pthread_mutex_unlock(&amp;fobj-&gt;mutex);</div>
<div class="line"><span class="preprocessor">#else  </span><span class="comment">/* _WIN32 */</span><span class="preprocessor"></span></div>
<div class="line">ReleaseSRWLockExclusive(&amp;fobj-&gt;lock);</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* _WIN32 */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">return</span> fobj-&gt;func_ptr;</div>
</div><!-- fragment --><p><span class="tt">pthread_mutex_t</span> / <span class="tt">SRWLOCK</span> はロック取得・解放時にメモリバリアを提供するため、<span class="tt">handle</span> や <span class="tt">func_ptr</span> への書き込み順序が他スレッドから正しく見えることが保証されます。</p>
<h2>初期化失敗時の再試行について</h2>
<p><span class="tt">resolved != 0</span> のチェックにより「一度実行したら以降はスキップ」という意味論が実現されます。<span class="tt">dlopen</span> / <span class="tt">LoadLibrary</span> が失敗した場合でも <span class="tt">resolved</span> が 0 以外に設定され、以降の呼び出しではロードを再試行しません。<span class="tt">resolved &lt; 0</span> の場合は <span class="tt">func_ptr == NULL</span> のままとなり、呼び出し元では NULL チェックで失敗を検出できます。</p>
<p><span class="tt">resolved</span> の状態値は以下のとおりです。</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">resolved  </th><th class="markdownTableHeadNone">意味  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">未解決  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">解決済  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">明示的デフォルト (<span class="tt">lib_name</span> と <span class="tt">func_name</span> がともに <span class="tt">"default"</span>)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">-1  </td><td class="markdownTableBodyNone">定義なし (定義ファイル不存在、定義行が不存在)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-2  </td><td class="markdownTableBodyNone">名称長さオーバー  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">-3  </td><td class="markdownTableBodyNone">ライブラリオープンエラー (<span class="tt">dlopen</span> / <span class="tt">LoadLibrary</span> 失敗)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-4  </td><td class="markdownTableBodyNone">関数探索エラー (<span class="tt">dlsym</span> / <span class="tt">GetProcAddress</span> 失敗)  </td></tr>
</table>
<h1>base.so / base.dll アンロード時の処理</h1>
<p><span class="tt">handle</span> に保持したハンドルは、<span class="tt">base.so</span> / <span class="tt">base.dll</span> がアンロードされるタイミングで自動的に解放されます。 アンロード処理は <span class="tt"><a class="el" href="dllmain__libbase_8c.html" title="base.so / base.dll のロード・アンロード時処理。">dllmain_libbase.c</a></span> に分離しており、<span class="tt"><a class="el" href="funcman__libbase_8h.html" title="funcman が管理する関数ポインタの extern 定義。">funcman_libbase.h</a></span> の <span class="tt">extern</span> 宣言で変数を共有します。プラットフォームごとのフックは <span class="tt"><a class="el" href="dllmain_8h.html" title="汎用 DLL ロード・アンロードフックヘッダー。">dllmain.h</a></span> が提供します。</p>
<h2>共通ヘルパー: <span class="tt"><a class="el" href="dllmain_8h.html#a817942d94fb255bd3eab726419c96e59" title="ライブラリのアンロード時に呼び出されるフック関数。">onUnload()</a></span> (<span class="tt"><a class="el" href="dllmain__libbase_8c.html" title="base.so / base.dll のロード・アンロード時処理。">dllmain_libbase.c</a></span>)</h2>
<p>Linux / Windows 共通のクリーンアップ処理を <span class="tt"><a class="el" href="dllmain_8h.html#a817942d94fb255bd3eab726419c96e59" title="ライブラリのアンロード時に呼び出されるフック関数。">onUnload()</a></span> にまとめています。Linux / Windows それぞれのエントリーポイント (<span class="tt"><a class="el" href="dllmain_8h.html" title="汎用 DLL ロード・アンロードフックヘッダー。">dllmain.h</a></span> が提供) からこの関数を呼び出します。</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="dllmain_8h.html#a817942d94fb255bd3eab726419c96e59">onUnload</a>(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_define" href="dllmain_8h.html#a76f99369d285962cdffb624890b6f752">DLLMAIN_INFO_MSG</a>(<span class="stringliteral">&quot;base: onUnload called&quot;</span>);</div>
<div class="line">    <a class="code hl_function" href="libbase_8h.html#ab6ac8fd3a68562d9fe127d4bf4a1a72f">funcman_dispose</a>(<a class="code hl_variable" href="funcman__libbase_8c.html#acfa26b00fb97511bfe8d54e7a23a08b7">fobj_array_libbase</a>, <a class="code hl_variable" href="funcman__libbase_8c.html#a98b8ee401eabe0512bf1c61eb0f42148">fobj_length_libbase</a>);</div>
<div class="line">}</div>
<div class="ttc" id="adllmain_8h_html_a76f99369d285962cdffb624890b6f752"><div class="ttname"><a href="dllmain_8h.html#a76f99369d285962cdffb624890b6f752">DLLMAIN_INFO_MSG</a></div><div class="ttdeci">#define DLLMAIN_INFO_MSG(msg)</div><div class="ttdoc">DllMain / constructor / destructor コンテキストで安全に 情報メッセージを出力するマクロ。</div><div class="ttdef"><b>Definition</b> <a href="dllmain_8h_source.html#l00047">dllmain.h:47</a></div></div>
<div class="ttc" id="adllmain_8h_html_a817942d94fb255bd3eab726419c96e59"><div class="ttname"><a href="dllmain_8h.html#a817942d94fb255bd3eab726419c96e59">onUnload</a></div><div class="ttdeci">static void onUnload(void)</div><div class="ttdoc">ライブラリのアンロード時に呼び出されるフック関数。</div><div class="ttdef"><b>Definition</b> <a href="dllmain__libbase_8c_source.html#l00057">dllmain_libbase.c:57</a></div></div>
<div class="ttc" id="afuncman__libbase_8c_html_a98b8ee401eabe0512bf1c61eb0f42148"><div class="ttname"><a href="funcman__libbase_8c.html#a98b8ee401eabe0512bf1c61eb0f42148">fobj_length_libbase</a></div><div class="ttdeci">const size_t fobj_length_libbase</div><div class="ttdoc">funcman に設定するポインタ配列の要素数</div><div class="ttdef"><b>Definition</b> <a href="funcman__libbase_8c_source.html#l00044">funcman_libbase.c:44</a></div></div>
<div class="ttc" id="afuncman__libbase_8c_html_acfa26b00fb97511bfe8d54e7a23a08b7"><div class="ttname"><a href="funcman__libbase_8c.html#acfa26b00fb97511bfe8d54e7a23a08b7">fobj_array_libbase</a></div><div class="ttdeci">funcman_object *const fobj_array_libbase[]</div><div class="ttdoc">funcman に設定するポインタ配列。</div><div class="ttdef"><b>Definition</b> <a href="funcman__libbase_8c_source.html#l00038">funcman_libbase.c:38</a></div></div>
<div class="ttc" id="alibbase_8h_html_ab6ac8fd3a68562d9fe127d4bf4a1a72f"><div class="ttname"><a href="libbase_8h.html#ab6ac8fd3a68562d9fe127d4bf4a1a72f">funcman_dispose</a></div><div class="ttdeci">BASE_API void WINAPI funcman_dispose(funcman_object *const *fobj_array, const size_t fobj_length)</div><div class="ttdoc">funcman_object ポインタ配列を解放します。</div><div class="ttdef"><b>Definition</b> <a href="funcman__dispose_8c_source.html#l00017">funcman_dispose.c:17</a></div></div>
</div><!-- fragment --><p><span class="tt">DLLMAIN_INFO_MSG</span> は DLL アンロードコンテキストの API 制約に合わせたログ出力マクロです。Linux では <span class="tt">syslog()</span>、Windows では <span class="tt">OutputDebugStringA()</span> を使用します。</p>
<p><span class="tt"><a class="el" href="libbase_8h.html#ab6ac8fd3a68562d9fe127d4bf4a1a72f" title="funcman_object ポインタ配列を解放します。">funcman_dispose()</a></span> はすべての <span class="tt"><a class="el" href="structfuncman__object.html" title="関数ポインタキャッシュエントリ。">funcman_object</a></span> を走査し、<span class="tt">handle != NULL</span> のものに対して <span class="tt">dlclose</span> / <span class="tt">FreeLibrary</span> を呼び出します。</p>
<h2>Linux: <span class="tt">__attribute__((constructor/destructor))</span> (<span class="tt"><a class="el" href="dllmain_8h.html" title="汎用 DLL ロード・アンロードフックヘッダー。">dllmain.h</a></span>)</h2>
<p><span class="tt"><a class="el" href="dllmain_8h.html" title="汎用 DLL ロード・アンロードフックヘッダー。">dllmain.h</a></span> が以下のフックを提供します。</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="dllmain_8h.html#a4d4bf980742769db8ad7ca3fdd754ab6">__attribute__</a>((constructor)) <span class="keyword">static</span> <span class="keywordtype">void</span> dllmain_on_load__(<span class="keywordtype">void</span>)   { <a class="code hl_function" href="dllmain_8h.html#ad9e1a525a9d307685c7a86b3dd0e814c">onLoad</a>(); }</div>
<div class="line"><a class="code hl_function" href="dllmain_8h.html#a4d4bf980742769db8ad7ca3fdd754ab6">__attribute__</a>((destructor))  <span class="keyword">static</span> <span class="keywordtype">void</span> dllmain_on_unload__(<span class="keywordtype">void</span>) { <a class="code hl_function" href="dllmain_8h.html#a817942d94fb255bd3eab726419c96e59">onUnload</a>(); }</div>
<div class="ttc" id="adllmain_8h_html_a4d4bf980742769db8ad7ca3fdd754ab6"><div class="ttname"><a href="dllmain_8h.html#a4d4bf980742769db8ad7ca3fdd754ab6">__attribute__</a></div><div class="ttdeci">__attribute__((constructor)) static void dllmain_on_load__(void)</div><div class="ttdoc">共有ライブラリロード時のコンストラクタ (Linux 専用)。</div><div class="ttdef"><b>Definition</b> <a href="dllmain_8h_source.html#l00075">dllmain.h:75</a></div></div>
<div class="ttc" id="adllmain_8h_html_ad9e1a525a9d307685c7a86b3dd0e814c"><div class="ttname"><a href="dllmain_8h.html#ad9e1a525a9d307685c7a86b3dd0e814c">onLoad</a></div><div class="ttdeci">static void onLoad(void)</div><div class="ttdoc">ライブラリのロード時に呼び出されるフック関数。</div><div class="ttdef"><b>Definition</b> <a href="dllmain__libbase_8c_source.html#l00024">dllmain_libbase.c:24</a></div></div>
</div><!-- fragment --><p><span class="tt">__attribute__((constructor/destructor))</span> を付与した関数は、以下のタイミングで呼ばれます。</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">トリガー  </th><th class="markdownTableHeadNone">呼び出しタイミング  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">dlopen(base.so)</span> されたとき  </td><td class="markdownTableBodyNone">ライブラリのロード直後 (constructor)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">dlclose(base.so)</span> で参照カウントが 0 になったとき  </td><td class="markdownTableBodyNone">ライブラリのアンロード直前 (destructor)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">プロセス正常終了 (<span class="tt">return</span> / <span class="tt">exit()</span>)  </td><td class="markdownTableBodyNone"><span class="tt">atexit</span> コールバックの後、OS へ制御が返る前  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">_exit()</span> / <span class="tt">abort()</span> による強制終了  </td><td class="markdownTableBodyNone"><b>呼ばれない</b>  </td></tr>
</table>
<h2>Windows: <span class="tt">DllMain</span> (<span class="tt"><a class="el" href="dllmain_8h.html" title="汎用 DLL ロード・アンロードフックヘッダー。">dllmain.h</a></span>)</h2>
<p><span class="tt"><a class="el" href="dllmain_8h.html" title="汎用 DLL ロード・アンロードフックヘッダー。">dllmain.h</a></span> が以下の <span class="tt">DllMain</span> を提供します。</p>
<div class="fragment"><div class="line">BOOL <a class="code hl_define" href="libbase_8h.html#a9aa60e1ead64be77ad551e745cbfd4d3">WINAPI</a> DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</div>
<div class="line">{</div>
<div class="line">    (void)hinstDLL;</div>
<div class="line">    (void)lpvReserved;</div>
<div class="line">    <span class="keywordflow">switch</span> (fdwReason)</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> DLL_PROCESS_ATTACH:</div>
<div class="line">        <a class="code hl_function" href="dllmain_8h.html#ad9e1a525a9d307685c7a86b3dd0e814c">onLoad</a>();</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> DLL_PROCESS_DETACH:</div>
<div class="line">        <a class="code hl_function" href="dllmain_8h.html#a817942d94fb255bd3eab726419c96e59">onUnload</a>();</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> TRUE;</div>
<div class="line">}</div>
<div class="ttc" id="alibbase_8h_html_a9aa60e1ead64be77ad551e745cbfd4d3"><div class="ttname"><a href="libbase_8h.html#a9aa60e1ead64be77ad551e745cbfd4d3">WINAPI</a></div><div class="ttdeci">#define WINAPI</div><div class="ttdoc">Windows 呼び出し規約マクロ。</div><div class="ttdef"><b>Definition</b> <a href="libbase_8h_source.html#l00059">libbase.h:59</a></div></div>
</div><!-- fragment --><p><span class="tt">DLL_PROCESS_DETACH</span> は以下のタイミングで呼ばれます。</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">トリガー  </th><th class="markdownTableHeadNone">呼び出しタイミング  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">FreeLibrary(base.dll)</span> で参照カウントが 0 になったとき  </td><td class="markdownTableBodyNone">ライブラリのアンロード直前  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">プロセス正常終了 (<span class="tt">return</span> / <span class="tt">ExitProcess()</span>)  </td><td class="markdownTableBodyNone">Windows ローダーがロード済み DLL を順にアンロードするとき  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">TerminateProcess()</span> による強制終了  </td><td class="markdownTableBodyNone"><b>呼ばれない</b>  </td></tr>
</table>
<blockquote class="doxtable">
<p><b>注意</b>: <span class="tt">DllMain</span> の <span class="tt">DLL_PROCESS_DETACH</span> ハンドラ内では、呼び出せる Win32 API が制限されています。<span class="tt">FreeLibrary</span> は <span class="tt">DLL_PROCESS_DETACH</span> から呼び出し可能ですが、<span class="tt">lpvReserved != NULL</span>（プロセス終了による DETACH）の場合はリソースは OS が回収するため、<span class="tt">FreeLibrary</span> を省略することもあります。本実装では明示的に解放しています。 </p>
</blockquote>
<h1>ハンドルを保持したままプロセスを終了した場合の影響</h1>
<p>キャッシュパターン採用時など、<span class="tt">dlclose</span> / <span class="tt">FreeLibrary</span> を呼ばずにプロセスを終了した場合の動作です。</p>
<p><b>結論: OS リソースの観点では問題ありません。ただしライブラリが外部リソースを管理している場合は注意が必要です。</b></p>
<h2>終了方法別の動作</h2>
<h3>Linux (dlopen)</h3>
<p>プロセスが <span class="tt">exit()</span> で終了すると、glibc の終了処理が以下を順に実行します。</p>
<ul>
<li><span class="tt">__cxa_atexit()</span> で登録されたコールバック (C++ 静的デストラクタを含む) を呼び出します</li>
<li>dlopen されたライブラリが <span class="tt">__cxa_atexit()</span> 経由でコールバックを登録していれば、dlclose なしでも呼び出されます</li>
<li>その後 OS がプロセスの全メモリマッピング・ファイルディスクリプタを回収します</li>
</ul>
<p><span class="tt">_exit()</span> や <span class="tt">abort()</span> による強制終了では glibc の終了処理をスキップするため、登録済みコールバックは呼ばれません。</p>
<h3>Windows (LoadLibrary)</h3>
<p>プロセスが正常終了 (<span class="tt">ExitProcess()</span> または <span class="tt">main</span> の return) すると、Windows ローダーが全ロード済み DLL の <span class="tt">DllMain</span> を <span class="tt">DLL_PROCESS_DETACH</span> で呼び出します。<span class="tt">FreeLibrary</span> していない DLL も対象になります。</p>
<p><span class="tt">TerminateProcess()</span> による強制終了では <span class="tt">DllMain</span> は呼ばれません。</p>
<h2>終了方法まとめ</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">終了方法  </th><th class="markdownTableHeadNone">Linux デストラクタ  </th><th class="markdownTableHeadNone">Windows DllMain(DETACH)  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">正常終了 (<span class="tt">return</span> / <span class="tt">exit()</span>)  </td><td class="markdownTableBodyNone">呼ばれる  </td><td class="markdownTableBodyNone">呼ばれる  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">_exit()</span> / <span class="tt">abort()</span>  </td><td class="markdownTableBodyNone">呼ばれない  </td><td class="markdownTableBodyNone">呼ばれない  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">TerminateProcess()</span>  </td><td class="markdownTableBodyNone">—  </td><td class="markdownTableBodyNone">呼ばれない  </td></tr>
</table>
<h2>注意が必要な外部リソース</h2>
<p>OS が回収できない外部リソースをライブラリの終了処理が管理している場合に影響が出ます。</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">外部リソースの例  </th><th class="markdownTableHeadNone">影響  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ファイル・ソケット  </td><td class="markdownTableBodyNone">OS がクローズするため問題ありません  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">プロセス間共有メモリ (<span class="tt">shm_open</span> / <span class="tt">CreateFileMapping</span>)  </td><td class="markdownTableBodyNone">他プロセスが参照中なら残存する可能性があります  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">名前付きミューテックス・セマフォ  </td><td class="markdownTableBodyNone">解放されずロックしたまま残存する可能性があります  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">一時ファイル・ロックファイル  </td><td class="markdownTableBodyNone">削除されずに残る可能性があります  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">外部サービスへの接続 (DB など)  </td><td class="markdownTableBodyNone">コネクションが即時切断されず、サーバ側で残留する可能性があります  </td></tr>
</table>
<h2>このサンプルへの適用</h2>
<p><span class="tt">liboverride</span> は乗算のみを行い外部リソースを一切管理していないため、ハンドルを保持したままプロセスを終了しても Linux・Windows ともに問題ありません。アンロード時処理はリソース管理の明示的な例として実装しています。 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
